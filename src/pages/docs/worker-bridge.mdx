## Worker Bridge


Worker-Bridge, an integral component of the Golem OSS worker-service, empowers you to define and upload API definitions.
These definitions allow you to expoes endpoints to users and  specify how incoming requests should be managed by your Golem worker workflow/application.

Let's dig a bit deeper using an example.

Say you already have a worker running in your Golem OSS (docker environment) or Golem Cloud.  Assuming you have already got the worker running in Golem with shopping-cart example,
let's say we have to expose an endpoint to get the cart contents for a user.  In order to do this, you would typically write a API definition as given below and simply upload to Golem.


At this point, worker-bridge is acting as an API-Gateway, but the major difference here is, it is geared
to work seamlessly with Golem. In other words, we don't need to specifically write a custom backend service as worker-bridge gives it for free.


```bash filename="Terminal" copy

{
  "id": "shopping-cart-v1",
  "version": "0.0.3",
  "routes": [
    {
      "method": "Get",
      "path": "/{user-id}/get-cart-contents",
      "binding": {
        "type": "wit-worker",
        "template": "2696abdc-df3a-4771-8215-d6af7aa4c408",
        "workerId": "worker-${request.path.user-id}",
        "functionName": "golem:it/api/get-cart-contents",
        "functionParams": [],
        "response" : "${worker.response}"
      }
    }
  ]
}

```

Let's break this down.

**id**: This field represents the unique identifier for the API definition. In this case, it is set to "shopping-cart-v1".

**version**: This field indicates the version of the API definition. Here, it is set to "0.0.3".

**routes**: This field contains an array of route objects, each representing a specific endpoint definition.

**method**: Indicates the HTTP method associated with the route. In this example, it is set to "Get", indicating that this route handles GET requests.

**path**: Specifies the URL path pattern for the route. It may include path parameters enclosed in curly braces. Here, the path is "/{user-id}/get-cart-contents", indicating that this route handles requests to retrieve the contents of a shopping cart for a specific user.

**binding**: This object contains information about how the request should be handled by the Golem worker.

### Golem Worker Binding

Let's break down the binding object.

**type**: Specifies the type of binding. Here, it is set to "wit-worker", indicating that the binding involves a Golem worker. Currently the only supported type is "wit-worker".

**template**: Provides the template ID associated with the worker binding.

**workerId**: Specifies the ID of the Golem worker responsible for handling the request. The value is wrapped in code block starting with `${` and ending with `}`. Anything wrapped in this block is an `expression`.
Refer to expression language details on various possibilities. In this example `${request.path.user-id}`, indicating that the worker ID is determined based on the user-id path parameter of the incoming request.
You would still use the same expression if `user-id` is a query parameter. Similarly, you can refer to the header values using `${request.header.user-id}`. In our example we are using path parameter and not headers or body.

**functionName**: Specifies the name of the function within the Golem worker that should be invoked to handle the request. Here, it is set to "golem:it/api/get-cart-contents".

**functionParams**: Specifies any parameters that should be passed to the function when it is invoked. In this case, it is an empty array []. If you need to pass any parameters, you can specify them here using an array of expressions. More examples on this down below.

**response**: The `response` field is an expression and can be used to manipulate the response before sending it back to the client. For example, you can extract specific fields from the worker response, transform the data, or add additional information.
In this example, it simply uses `${worker.response}` to include the response as is. Depending on the protocol used, (HTTP, gRPC, etc.), the response can be formatted accordingly. More examples on this down below.


### Upload Golem Worker Binding

You can either use `Golem-CLI` or REST endpoints or `Golem-UI` (available only in golem-cloud) to upload the API definition to Golem.
The support for Golem-CLI is yet to be released. For now, you can use the REST endpoint to upload the API definition.

```bash filename="Terminal" copy
curl -X POST http://localhost:9881/v1/api/definitions -H "Content-Type: application/json"  -d @worker_service_api_definition.json
```

Here `localhost:9881` is where worker-service (that consist of worker-bridge functionality) is running. The docker-compose example (explained in quick-start) currently exposes the port 9881 for worker-service.

### Deploy the API Definition

Similar to many API Gateways, it is a separate process to deploy this API definition. This is because, the API definition is not immediately available for use after uploading.
With deployment you tag a `site`. The `site` can be as simple as `localhost:9881` for you to test it, or if you already have a domain registered (say my-site.com), you can deploy the API definition to `my-site.com`.

Let's create a `deployment.json` as given below. Based on the example above, the apiDefinitionId is `shopping-cart-v1` and version is `0.0.3`.
The `site` is set to `localhost:9881` because we are testing it locally, and the host in in-coming request will be `localhost:9881`. If you were having a domain registered such as `my-site.com`, you would replace `localhost:9881` with `my-site.com`,
that in turn redirects to `localhost:9881`, or wherever the worker-service is running.

```bash filename="Terminal" copy

{
  "apiDefinitionId": "shopping-cart-v1",
  "version": "0.0.3",
  "site": "localhost:9881"
}
```

```bash filename="Terminal" copy
curl -X POST http://localhost:9881/v1/api/deployments -H "Content-Type: application/json"  -d @deployment.json
```

### Start using the API

At this point, we are ready to use the API. You can use any REST client to make a GET request to the cart content endpoint

```bash filename="Terminal" copy
curl -X GET http://localhost:9881/123/get-cart-contents
```

Now worker-bridge identifies the user to be `123` and evaluates the worker-id expr to be `worker-123`. It then forwards the request to the worker with id `worker-123` and invokes the function `golem:it/api/get-cart-contents` with empty parameters,
and simply get the worker-response (which is a WASM value) and converts it to `Json` and sends it back to the client.

### Response Mapping

In the above example, we simply used `${worker.response}` to include the response as is. However, you can perform more complex transformations on the response before sending it back to the client.
We recommend taking a quick look at the expression language before reading further.

Since we are using Http protocol, worker-bridge allows you to write a record expression that consist of `status`, `headers` and `body` fields. The `status` field is the HTTP status code, `headers` is a map of HTTP headers, and `body` is the response body.

Usually our worker.response is an Array of WASM values. This is regardless of the domain/use-case. It implies, in shopping cart example, the response is an array of array of objects. Each object in the inner array represents a product in the cart.
That is `worker.response[0]` will fetch the first element in the array, and this element is a sequence of product information.
In this case, our expression of response can be something like this. Note that we are also injecting some headers in the response using expression language.

```bash filename="Terminal" copy
...
{ status: 200, body : worker.response[0], headers: {etag: 1}
```

Now the above expression can be embedded into the response field of API definition. Now we know that it is going to be read as an expression only if we wrap it in `${` code block

```bash filename="Terminal" copy

"response" : "${{ status: 200, body : worker.response[0], headers: {etag: 1} }}"
```


